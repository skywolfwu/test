1.标示符：由数字，字母，下划线组成，数字不能开头。
2.查看关键字有哪些；import keyword 
                   keyword.kwlist
3. 不等于符号：！=    not 表示取反
4.\t 表示加一个tab键
5.一个字节的最大值为255
6.字符串每一个位数占一个字节
7.name[2:-1:3]3为步长
8.列表
添加新的元素
append（） insert（）  extend（）
删除元素
pop（）----      删除最后一个
remove（）------根据内容删除
del xxx[下标]-------根据下标删除 
改  xxx[0]="  "
9.元组只能看
10.两个大于号整体有缩进
11.将函数值返回到调用的地方，存起来给另一个函数使用
12.一遇到return，函数即结束
13.函数内的变量只能在函数内使用----局部变量
14.函数内有局部变量用局部变量，不用全局变量
15.缺省参数，命名参数,不定长参数

16.（33，）
17.python中数字，字符串，元组是不可变类型
18.将key通过算法得到唯一的一个数值，用来存储内容---哈西算法
19.可变类型不能用来当keys
20.eval可以将字符串的的引号去掉
21.将两个变量互换a=a+b,b=a-b,a=a-b;a,b=b,a
22.a+=a  !=  a=a+a  一个是修改里面的值，一个是重新开辟一个内存进行计算
23.8,16s/cooked/cooketime/g 将8到16 行cooked改成cookedtime
24.import sys 
sys.getrefcount() 此命令可以查看一个对象的引用计数
25.__del__()方法，当删除对象的引用计数时，还有引用计数存在，则在程序执行完后，执行此方法，如果引用计数没有了，则立马执行此方法，再执行完程序
26.super().--可以调用父类以及父类的父类的方法
27.私有属性和方法不能直接被调用；如果调用的是 继承的父类中的公有方法 可以在这个公有方法中访问父类中的私有属性2和方法；但如果在子类中实现了一个公有方法，那么这个方法是不能沟调用继承的父类中的私有方法和私有属性
28.print(类名.__mro__)   查看调用相同方法的优先顺序
29.python即支持面向对象也支持面向过程，python语言面向对象的三个基本要素是什么：封装，继承，多态，什么是封装，把函数和全局变量全都封装在一起；继承：子类继承父类；多态：调用的时候才确定调用子类还是父类的
30.类属性属于类对象，并且多个实例对象共享一个类属性
31.数字0表示假，数字非0表示真，有内容的字符串，表格，字典表示真。
32.pip3  pip 管理模块的工具，模块实际上就是一个py文件。
33.if __name__=="__main__": 表示如果是自己调用这个模块条件成立，别人调用这个模块是条件不成立
34.独立显卡是在内存之外开辟一个空间显示信息。延时可以降低CPU的利用率但是程序会卡一点（迟钝）
35.用死循环完成了一个重叠的画面,两个死循环只有一个可以执行
36.在循环中删除会有问题，可以将要删除的对象存起来在进行循环来删除。
37.函数:将具有独立功能的代码块封装起来
38.*args 以元组的形式存储,*kwargs以字典的形式存储,,,,,,导入模块会有一个搜索路径
39.==与is的区别, ==用与判断内容是否相同, is用来判断是否是同一个对象
40.浅拷贝的结果是一个内容的引用多了一个如b=a.深拷贝顾名思义,import copy  c=copy.deepcopy(a)
41.copy.copy(a),如果a是一个不可变类型,结果是多了一个引用,如果a是可变类型拷贝了一层,最终的内容一样
42.1B=8bit,byte 8个二进制数表示一个字节,1bit表示一位二进制数
43.#不是重点    左移一位表示乘以2,右移一位表示除以2,5<<1,5<<2.高效快速,8>>3,相当于8除以2的三次方,.... | 按位或
有1就1 只要对应的二个二进位有一个为1时,结果位就为1,否则为0,^表示异或运算,补码转换成原码规则是符号位不变取反加1
44._x: 单前置下划线,私有化属性或方法,from somemodule import *禁止导入,以及__x        import somemodule somemodule.__x  可以用         私有属性实际上进行了名字重整,_类名_属性名
45.闭包:在函数内部再定义一个函数,并且这个函数用到了外边函数的变量   %s/^/#/g  所有行开头加#    函数名重名之前定义的函数就废了
46.Python 使用 LEGB 的顺序来查找一个符号对应的对象   locals -> enclosing function -> globals -> builtins
47.intern机制:共用同一个对象  含有空格的字符串,没开启intern机制,不共用对象  对不可变类型的修改实际上是创建一个新的对象
 引用计数不能处理环形数据结构--循环引用的数据结构  refcount 引用计数
48. pdb 调试工具 python3 -m pdb test.py     l: 显示代码 n:执行一行代码 c:执行代码 b:添加断点 clear:删除断点  p:打印变量的值
 s(step):进入到一个函数内   a(args):打印所有的形参数据  r--return执行到程序最后一行  python编码风格可查pep8中文  编写完毕的代码,在没有运行的时候,称之为程序
49.父进程返回值是子进程的pid(进程号)  os.fork()父进程返回的是一个大于0的值,子进程返回的是一个0.
50.
p.join()#堵塞

print("----main----")
51.没有运行的代码就是程序,运行的代码就是进程.进程里包括线程.僵尸进程:子进程死了之后父进程没有取回子进程的内存空间.孤儿进程  线程之间共享全局变量
52.死循环的来判断某一个条件称之为轮询   一把互斥锁,会抢着上锁,如果一方上锁成功,其他想用这个锁时被卡住了    threading.current_thread().name  vim 中大写V表示可视行 v表示可视  x剪切 p粘贴
53.多个线程,每个线程执行的函数里的变量个人是个人的 多个线程有顺序的执行为同步 fifo先进先出 filo先进后出  from queue import Queue 线程间的队列  local_school = threading.local()(在线程课件里可查到(Threadlocal))  可以区分线程(的变量) 
线程效率不高是因为存在GIL 如果想要提高线程效率,并且还是用线程完成任务,可以将任务用c语言去写,之后编译成动态库,再写一个py文件去加载动态库并且创造线程去运行   计算机都遵守的网络通信协议叫做 TCP/IP协议  tcp/ip协议层次 链路层,网络层,传输层,应用层.  或者   物理层,数据链路层,网络层,传输层,会话层,表示层,应用层  端口可以有65536(2的16次方)个之多  端口号只有整数,范围是从0到65535  用“netstat -an”查看端口状态  每一个IP地址包括两部分:网络地址和主机地址  socket插座 套接字  udp理解为写信 tcp理解为打电话 
54.在同一个os中,端口不允许相同,如果这个端口已经被使用了,那么在这个进程释放端口之前,其他进程不能使用这个端口
55.单工:只能发或者收 半双工:同一时刻只能发或者收 全双工:同一时刻既可以发也可以收  utf-8 gb2312   shadowsocks 翻墙软件


























